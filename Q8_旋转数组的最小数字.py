# encoding: utf-8
"""
 @project:JianZhi_offer
 @author: Ma Qian
 @language:Python 2.7.2 
 @time: 2019/8/20 上午8:45
 @desc:
"""
'''
题目： 把一个数组最开始的若干个元素搬到数组的末尾。我们称之为数组的旋转。
输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。
例如：数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1
'''

'''
这道题的直观解法并不难，从头到尾遍历数组一次，我们就能找出最小的元素，这种思路的时间复杂度为O(n),但是这个思路没有利用旋转数组的特点。
我们注意到，旋转之后的数组实际上可以划分为两个排序的子数组，而且前面的子数组的元素都大于等于后面子数组的元素。我们还注意到，
最小的元素刚好是这两个子数组的分界线。在排序数组的查找中我们可以使用二分查找实现O(logn)的时间复杂度。

本题给出的数组在一定程度上是有序的，所以我们可以试着用二分查找法的思路来查找最小元素。
'''

'''
情形1：正常情况：和二分查找法一样，使用两个指针，一个指向数组第一个元素，一个指向数组最后一个元素，按照旋转数组的特点，第一个元素
应该大于最后一个元素,找到中间的元素后，
            如果中间元素大于第一个元素，说明最小的元素在中间元素的后面，
            如果中间元素小于最后一个元素，说明最小的元素在中间元素的前面。
      直到第一个指针指向前面子数组的最后一个元素，第二个指针指向后面子数组的第一个元素，那么第二个指针指向的就是最小元素

情形2：特殊情况：使用两个指针，一个指向数组第一个元素，一个指向数组最后一个元素，按照旋转数组的特点，
        如果第一个元素就小于最后一个元素，说明旋转数组是将前面的0个元素搬到了后面，即没有进行旋转，那么第一个元素就是最小元素

情形3：特殊情况：
    如果原始数组为： [0, 1, 1, 1, 1] 
        旋转数组为：[1, 0, 1, 1, 1]
    此时使用二分查找就没有用了，就需要使用顺序查找。
'''


def find_min(arr):
    if len(arr) == 0:
        return False
    low = 0
    high = len(arr) - 1
    while arr[low] >= arr[high]:
        if high - low == 1:
            return arr[high]

        mid = (low + high) / 2
        if arr[low] <= arr[mid]:
            low = mid
        if arr[high] >= arr[mid]:
            high = mid
        if arr[low] == arr[high] == arr[mid]:
            return min(arr)

    return arr[0]


# arr = [3, 4, 5, 6, 1, 2]
# arr = [0, 1, 3, 4, 6]
arr = [1, 0, 1, 1, 1, 1]
print find_min(arr)
