# encoding: utf-8
"""
 @project:JianZhi_offer
 @author: Ma Qian
 @language:Python 2.7.2 
 @time: 2019/9/11 下午4:04
 @desc:
"""
'''
题目：输入n个整数，找出其中最小的k个数。
     例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4.
'''

'''
解法1：O（n）的算法，只有当我们可以修改输入的数组使可用
    从Q29_数组中出现次数超过一半的数字题目中得到启发。我们可以同样基于快速排序来解决这个问题，如果基于数字的第k个数字
来调整，使得比第k个数字小的所有数字都位于数组的左边，这样位于数组左边的的k个数字就是最小的第k个数字（但是不一定是排序的）。
    基于这种思路是有限制的。我们需要修改输入的数组，因为快速排序会调整数组中数字的顺序。
    
'''

'''
解法2：O（nlogk）的算法，特别适合处理海量数据
    我们可以先创建一个大小为k的数据容器来存储最小的k个数字，接下来每次从输入的n的整数中读入一数。如果容器中已有的数字少
于k个，则直接把这次读入的数字放入容器中，如果容器中已有k个数字了，也就是容器已经满了，我们就需要替换已有的数字：找出已有
的k个数字中的最大值，然后用这次读入的整数和最大值进行比较。如果此次读入的整数小于当前最大值，则用此次读入的数字代替最大值，
如果读入数字比最大值大，则此次读入数字肯定不可能是最小的k个整数之一，直接略过。
    因为当容器满了之后，我们可能要做的是3件事情：
    ①找出k个整数中的最大值
    ②删除最大值
    ③插入一个新的数字

    如果用一个二叉树来实现这个数据容器，那么我们能在O（logk）的时间内实现这3步操作。
    可选的有最大堆或者红黑树，但是红黑树太复杂，这里采用最大堆：
'''
'''
特殊的二叉树之二：
    2.堆：堆也被称为优先队列。队列中允许的操作是先进先出，在队尾插入元素，在队头取出元素，而堆也一样，在堆底插入元素，在堆顶取出
元素。但是堆中元素的排列不是按照到达的先后顺序，而是按照一定的优先循序排列的，这个优先顺序可以是元素的大小或者其他规则。堆一般分为
最大堆和最小堆。最大堆中根节点的值最大，并且每一个分支都可以看成一个最大堆。最小堆的定义与之对应。

最大堆的插入：先插入到最后一个元素的后面（完全二叉树的形式），然后将该元素持续与其父节点对比，如果大于父节点，则交换，直到小于父节
            点或者到达根节点。
最大堆的删除：删除的是堆顶，然后将最后一个元素放到根节点中，然后比较该结点与其两个子节点的大小，将最大值放在父节点上。
最小堆的插入和删除类似。

Python中，堆可以使用数组、列表实现：一个下标为j的结点的父节点为int((j-1)/2)
也可以使用二叉树的结构来实现堆。
另外Python中有内置的堆实现：heapq
使用：
    import heapq as hq
    import random
    imprort numpy as np
    data = np.arange(10)
    data = random.shuffle(data)
    heap = []
    for i in data:
        hq.heappush(heap, i)
    hq.heappop(heap)

另外：Python自带的heapq模块实现的是最小堆，没有提供最大堆的实现。虽然有些文章通过把元素取反再放入堆，出堆时再取反，把问题
     转换为最小堆问题也能间接实现最大堆，但是这样的实现只适合数值型的元素，不适合自定义类型。

'''


import heapq


data = [6, 5, 9, 0, 8, 7, 1, 4, 3, 2, -2, -3]
k = 4

maxheap = []
j = 0
for i in data:
    if j < k:
        heapq.heappush(maxheap, -1 * i)
        j += 1
    else:
        max_of_k_nums = heapq.heappop(maxheap) * (-1)
        if i > max_of_k_nums:
            heapq.heappush(maxheap, -1 * max_of_k_nums)
        else:
            heapq.heappush(maxheap, -1 * i)
        j += 1

reslut = []
for l in range(0, k):
    reslut.append(-1 * heapq.heappop(maxheap))

print sorted(reslut)






