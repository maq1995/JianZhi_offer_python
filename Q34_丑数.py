# encoding: utf-8
"""
 @project:JianZhi_offer
 @author: Ma Qian
 @language:Python 2.7.2 
 @time: 2019/9/12 下午4:16
 @desc:
"""
'''
题目：我们把只包含因子2、 3、 5的数称作丑数。求按从小到大的顺序的第1500个丑数。例如6,8都是丑数，但14不是，因为它包含因子7，
    习惯上我们把1当做第一个丑数。
    所谓一个数m是另一个数n的因子，是指n能被m整除，也就是n%m=0。根据丑数的定义，丑数只能被2、 3、 5整除。也就是说如果一个数
能被2整除，我们把它连续除以2；如果能被3整除，就连续除以3；如果能被5整除，就；连续除以5,。如果最后得到1，那么这个数就是丑数。

解析：
    如果按照上述的方法进行判断的话，代码直观但是不够高效。之所以效率低，很大程度上是因为不管一个数是不是丑数我们都要对他进行
计算，接下来我们试着计算一种只计算丑数的方法，而不在非丑数上花费时间。
    根据丑数的定义，丑数应该是一个丑数乘以2、 3、 5的结果（1除外），因此我们可以创建一个数组，里面的数字是排好序的丑数，每一
个丑数都是前面的丑数乘以2、 3、 5得到的。
    这个思路的关键在于怎样确保数组里面的丑数都是排好序的。假设数组中已经有若干个丑数排好序后存放在数组中，并且把已有最大的
丑数记做M，我们接下来分析如何生成下一个丑数。该丑数肯定是前面某一个丑数乘以2、 3或 5的结果，所以我们首先考虑把已有的每个丑数
乘以2，在乘以2的时候，能够得到若干个小于或者等于M的结果，由于是按照顺序生成的，小于或者等于M的数肯定已经在数组中了，我们不需
要考虑；还会得到若干个大于M的结果，但我们只需要第一个大于M的结果，因为我们希望丑数是按从小到大的顺序生成的，其他大的结果以后
再说。我们把达到的第一个乘以2之后大于M的结果记为M_2。同样我们把已有的每一个丑数乘以3和5，能得到第一个大于M的结果M_3和M_5，
那么下一个丑数应该是M_2、M_3和M_5的最小者。
    前面分析的时候，提到把已有的每个丑数分别乘以2、 3、 5 。事实上这不是必须的，因为已有的丑数是按照顺序存放在数组中的。
对乘以2而言，肯定存在某一个丑数T_2，排在它前面的每一个丑数乘以2得到的结果都会小于已有最大的丑数，在它之后的每一个丑数乘
以2得到的结果都会大于最大的丑数，我们只需记下这个丑数的位置，同时每次生成新的丑数的时候，去更新这个T_2；同样，对乘以3和
5而言，也存在T_3和T_5.
'''


def getUglyNumber(index): # 得到第index个丑数
    if index <= 0:
        return None
    ugly = [1]
    t2 = t3 = t5 = 0
    while len(ugly) < index:
        while ugly[t2] * 2 <= ugly[-1]:
            t2 += 1
        while ugly[t3] * 3 <= ugly[-1]:
            t3 += 1
        while ugly[t5] * 5 <= ugly[-1]:
            t5 += 1
        ugly.append(min(ugly[t2] * 2, ugly[t3] * 3, ugly[t5] * 5))

    # return ugly
    return ugly[-1]


print getUglyNumber(1)