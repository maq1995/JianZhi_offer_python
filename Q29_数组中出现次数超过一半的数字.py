# encoding: utf-8
"""
 @project:JianZhi_offer
 @author: Ma Qian
 @language:Python 2.7.2 
 @time: 2019/9/11 下午3:02
 @desc:
"""
'''
题目：数组中有一个数字出现的次数超过数组长度的一半。请找出这个数字。
     例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}，由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2.
     
'''

'''
解法1：
    考虑数组的特性：数组中有一个数字出现的次数超过了数组长度的一半，如果把这个数组排序，那么排序后位于数组中间的数字一定
就是那个出现次数超过数组长度一半的数字。也就是说，这个数字是统计学上的中位数，即长度为n的数组中第n/2大的数字。
    我们有成熟的O（n）的算法得到数组中任意第k大的数字：随机快速排序
    这种算法是受快速排序算法的启发，在随机快速排序中，我们先在数组中随机选择一个数字，然后调整数组中数字的顺序，使得比选中的
数字小的排在它的左边，比它大的排在它的右边（即一趟快速排序），一趟快排之后，如果这个选中的数字的下标刚好是n/2，那么这个数字就
是数组的中位数，如果它的下标小于n/2，那么中位数就位于它的右边，反之，则中位数在它的左边。我们可以接着在它的左边或右边的数组中
查找，这是一个典型的递归过程。
'''


'''
解法2：
    接下来我们从另一个角度来解决这个问题。
    数组中有一个数字出现的次数超过数组长度的一半，也就是说它出现的次数比其他所有数字出现的次数之和还要多。因此我们在遍历数组时
保存两个值：一个是数组中的一个数字，一个是次数。当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1，
如果下一个数字和我们之前保存的数字不同，则次数减1，如果次数为0，我们需要保存下一个数字，并将次数设为1.
    由于我们要找的数字出现的次数比其他数字出现次数之和还要多，那么要找的数字肯定是最后一次把次数设为1时对应的数字。
'''


def MoreThanHalfNums(arr):
    # 判断数组是够为无效输入
    if not arr or len(arr)<=0:
        return None
    resullt = arr[0]
    times = 1

    for i in range(1, len(arr)):
        if times == 0:
            resullt = arr[i]
            times = 1
        elif resullt == arr[i]:
            times += 1
        else:
            times -= 1

    # 当出现次数多的数字找到了，但是它的出现次数不大于数组长度一半，就不符合要求
    count = 0
    for j in arr:
        if j == resullt:
            count += 1
    return resullt if count*2 > len(arr) else None


arrary = [1, 2, 3, 2, 2, 2, 5, 4, 2]
arrary1 = [1, 2, 3, 3, 2, 2, 5, 4, 2]
arrary2 = [1]
arrary3 = []
print MoreThanHalfNums(arrary3)






